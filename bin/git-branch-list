#!/usr/bin/env ruby
require_relative '../lib/git_helper'

# Branch representation
class Branch
  include GitHelper
  def initialize(data)
    @hash = data[:hash]
    @local_name = data[:local_name]
    @message = data[:message]
    @is_gone = data[:is_gone] || false

    @position = parse_position(data[:position])
    @remote = data[:remote]
    @distant_name = data[:distant_name]

    data = commit_info(@hash)
    @date = data[:date]
    @date_relative = data[:date_relative]
  end

  def parse_position(position)
    return nil if position.nil?
    position.gsub('ahead ', '+').gsub('behind ', '-').to_i
  end

  def current?
    current_branch == @local_name
  end

  def data_as_array
    display = []
    # Mark current branch
    if current?
      display << ''
    else
      display << ' '
    end


    # Marker
    display << push_pull_indicator(@local_name)

    if @local_name == @distant_name
      display << @local_name
    else
      display << "#{@local_name}:#{@distant_name}"
    end

    display << @hash

    if Time.now.to_i - @date.to_time.to_i > 48 * 60 * 60
      display << " #{@date_relative}"
                 .gsub('weeks', 'w.')
                 .gsub('days', 'd.')
                 .gsub(' ago', '')
    else
      display << nil
    end

    display << @message

    display
  end
end

# Display the complete list of all branches
class GitBranchListAll
  include GitHelper

  def initialize(*args)
    @args = get_flag_args(args)
    @branches = branches
  end

  def branches
    output = `git branch -vv`
    current_remote = current_remote()
    branches = []
    output.each_line do |line|
      p line
      raw_branch_name, hash, message = line.match(/^.{2}(.*) ([a-f0-9]{7}) (.*)$/).captures
      local_name = raw_branch_name.strip
      # If nothing is specified, it points to current remote and on a branch
      # with the same name
      distant_name = local_name
      remote = current_remote

      # Current branch is detached
      if local_name[0] == '('
        local_name = 'HEAD'
        distant_name = 'HEAD'
      end

      # message contains distant branch and ahead/behind/gone information
      if message[0] == '['
        distant_name, _, position, message = message.match(/^\[([^ :]*)(: )?(.*)\] (.*)/).captures
        is_branch_gone = (position == 'gone')
        split = distant_name.split('/')
        remote = split.shift
        distant_name = split.join('/').delete(']')
      end

      branches << Branch.new(
        local_name: local_name,
        distant_name: distant_name,
        remote: remote,
        is_gone: is_branch_gone,
        hash: hash,
        position: position,
        message: message
      )
    end
    branches
  end

  def run
    lines = pad_two_dimensionnal_array(@branches.map(&:data_as_array))

    # Colorize output
    output = lines.map do |line|
      branch_name = line[2]
      # Current branch
      line[0] = colorize(line[0], color(:valid))
      # Marker
      line[1] = colorize(line[1], branch_color(branch_name.strip))
      # Name
      line[2] = colorize(line[2], branch_color(branch_name.strip))
      # hash
      line[3] = colorize(line[3], color(:hash))
      # date
      line[4] = colorize(line[4], color(:date))
      # message
      line[5] = colorize(line[5], color(:message))
      line.join(' ')
    end
    puts output
  end
end
GitBranchListAll.new(*ARGV).run
